\documentclass[../../../main.tex]{subfiles}
\begin{document}

\subsection{Rectangular Method}
Rectangular integration approximates the area under a curve by summing the areas of rectangles.
The interval $[a,b]$ is divided into $s$ subintervals of equal width $h$, then the method is expressed as
\begin{equation*}
    \int_{a}^{b} f(x) \; dx \approx h \sum_{k=0}^{n-1} f(a + hk)
\end{equation*}
where
\begin{equation*}
    h=\frac{b-a}{n}
\end{equation*}

\subsubsection{Derivation.}
Rectangular integration is derived by approximating the integral as the sum of the areas of rectangles with height \( f(x_i) \) and width \( h \), yielding
\[
    \int_a^b f(x)\,dx \approx \sum_{i=0}^{n-1} f(x_i)h
\]

\subsubsection{Implementation.} As following
\begin{minted}[breaklines]{python}
def rect(x, y):
    luas = 0
    for i in range(len(x) - 1):
        dx = x[i + 1] - x[i]
        luas += y[i] * dx
    return luas
\end{minted}
The loop iterates over all intervals between consecutive points in \verb|x| using \verb|len(x)-1| since \verb|n| point define \verb|n-1| interval, so the loop must run \verb|n-1| times.
For each subinterval, the width is computed \verb|dx|.
The product \verb|y[i] * dx| gives the area of one rectangle, which is added to the total area \verb|luas|.
After summing over all rectangles, the total \verb|luas| approximates the definite integral of $f(x)$ over the domain.

\subsection{Trapezoid Method}
The trapezoidal integration method based on replacing the curve over each subinterval with a straight line (a trapezoid).
Let the points be $x_0=a$, $x_1=a+h$,\dots, $x_n=b$
The method is expressed as
\begin{equation*}
    \int_a^b f(x)\,dx \approx \frac{h}{2} \Big[f(x_0) + 2\sum_{i=1 }^{n-1 }f(x_i)+ f(x_n) \Big].
\end{equation*}
with
\begin{equation*}
    h = \frac{b-a}{n}
\end{equation*}

\subsubsection{Derivation.}
Consider a function $f(x)$ defined on $[a,b]$. Divide the interval into $n$ subintervals of equal width
\[
    h = \frac{b-a}{n},
\]
with points $x_0 = a, x_1 = a+h, \dots, x_n = b$ and function values $f(x_i)$.
The area over a single subinterval $[x_i, x_{i+1}]$ can be approximated by a trapezoid:
\[
    \int_{x_i}^{x_{i+1}} f(x)\,dx \approx \frac{h}{2} \left(f(x_i) + f(x_{i+1})\right).
\]
Summing over all subintervals:
\begin{align*}
    \int_a^b f(x)\,dx & \approx \sum_{i=0}^{n-1} \frac{h}{2} \left[f(x_i) + f(x_{i+1})\right]                          \\
                      & =  \frac{h}{2} \Big[f(x_0) + (f(x_1)+f(x_1)) + \dots + (f(x_{n-1})+f(x_{n-1})) + f(x_n) \Big].
\end{align*}
Simplifying the repeated terms for interior points:
\[
    \int_a^b f(x)\,dx \approx \frac{h}{2} \Big[f(x_0) + 2 f(x_1) + 2 f(x_2) + \dots + 2 f(x_{n-1}) + f(x_n) \Big].
\]
\subsubsection{Implementation.}
\begin{minted}[breaklines]{python}
def trapez(x, y):
\end{minted}
The function \verb|trapez| implements the composite trapezoidal rule for numerical integration applied to tabulated data \((x_{i}, y_{i})\).
\begin{minted}[breaklines]{python}
    luas = 0
\end{minted}
The variable \verb|luas| is initialized as zero and accumulates the integral estimate.
\begin{minted}[breaklines]{python}
    for i in range(len(x) - 1):
        dx = x[i + 1] - x[i]
        luas += 0.5 * (y[i] + y[i + 1]) * dx
\end{minted}
For each index \(i\), the quantity \verb|dx| represents the interval width \(x_{i+1} - x_{i}\).
The area contribution over this interval is computed as \(\tfrac{1}{2}(y_{i}+y_{i+1})\, dx\), corresponding to the area of a trapezoid whose parallel sides have lengths \(y_{i}\) and \(y_{i+1}\).
Summing these contributions over all subintervals produces the composite trapezoidal approximation.
\begin{minted}[breaklines]{python}
    return luas
\end{minted}
The returned value represents the numerical estimate of the integral over the domain spanned by the grid points.

\subsection{Simpson's Method}
The Simpson 1/3's rule is given by
\begin{equation*}
    \int_{x_0}^{x_2} f(x)\,dx \approx \frac{h}{3} \left( f(x_{0}) + 4f(x_{1}) + f(x_{2}) \right),
\end{equation*}
where \( h = x_1 - x_0 \).
Another method is called Simpson's 3/8 rule
\begin{equation*}
    \int_{x_0}^{x_3} f(x)\,dx \approx \frac{3h}{8} \left( f(x_{0}) + 3f(x_{1}) + 3f(x_{2}) + f(x_{3}) \right).
\end{equation*}

For a large number of subintervals, Simpson’s 1/3 and 3/8 rules are extended to composite forms. The interval \([a,b]\) is divided into \(n\) equally spaced subintervals of width \(h\):
\[
    h = \frac{b-a}{n}.
\]
If \(n\) is even, which is required by this method, the {Composite Simpson's 1/3 Rule} is applied:
\[
    \int_a^b f(x)\,dx \approx \frac{h}{3} \left[ f(x_{0}) + 4 \sum_{i=1,3,5,\ldots}^{n-1} f(x_{i}) + 2 \sum_{i=2,4,6,\ldots}^{n-2} f(x_{i}) + f(x_n) \right].
\]
If \(n\) is not a multiple of two, the last three intervals can be evaluated using the {3/8 Rule} to cover the remainder.

\subsubsection{Derivation.}
We demonstrate for the case of 1/3 case, i.e. $n=2$ for the Lagrange interpolation.
Using Lagrange interpolation, the quadratic polynomial passing through the three points is
\begin{equation*}
    P_{2}(x) = f_{0} \frac{(x - x_{1})(x - x_{2})}{(x_{0} - x_{1})(x_{0} - x_{2})} + f_{1} \frac{(x - x_{0})(x - x_{2})}{(x_{1} - x_{0})(x_{1} - x_{2})} + f_{2} \frac{(x - x_{0})(x - x_{1})}{(x_{2} - x_{0})(x_{2} - x_{1})}
\end{equation*}
The integral then simplify
\begin{equation*}
    \int_{x_0}^{x_2}f(x)\;dx\approx
    \int_{x_0}^{x_2}P_2(x)\;dx
\end{equation*}
Now we evaluate the Lagrange interpolation by considering
\begin{equation*}
    x_1 - x_0 = h, \quad x_2 - x_0 = 2h, \quad x_2 - x_1 = h.
\end{equation*}
Now the Lagrange basis turns
\begin{align*}
    L_0(x) & = \frac{(x-x_1)(x-x_2)}{2h^2}, \\
    L_1(x) & = \frac{(x-x_0)(x-x_2)}{-h^2}, \\
    L_2(x) & = \frac{(x-x_0)(x-x_1)}{2h^2},
\end{align*}
Change variable $x = x_0 + t$, $dx = dt$, $t \in [0, 2h]$:
\[
    L_0(t) = \frac{(t-h)(t-2h)}{2h^2}, \quad
    L_1(t) = \frac{t(t-2h)}{-h^2}, \quad
    L_2(t) = \frac{t(t-h)}{2h^2}.
\]
Integrating each basis polynomial:
\[
    \int_0^{2h} L_0(t)\,dt = \frac{h}{3}, \quad
    \int_0^{2h} L_1(t)\,dt = \frac{4h}{3}, \quad
    \int_0^{2h} L_2(t)\,dt = \frac{h}{3}.
\]
Combining the integrals gives
\[
    \int_{x_0}^{x_2} f(x)\,dx \approx f(x_0) \frac{h}{3} + f(x_1) \frac{4h}{3} + f(x_2) \frac{h}{3} = \frac{h}{3} \left[f(x_0) + 4 f(x_1) + f(x_2) \right].
\]

\subsubsection{Implementation.}
\begin{minted}[breaklines]{python}
def simpson(x, y):
\end{minted}
The function \verb|simpson| implements the classical Simpson rule for numerical integration applied to tabulated data \((x_{i}, y_{i})\).
\begin{minted}[breaklines]{python}
    n = len(x) - 1
    if n % 2 != 0:
        raise ValueError("Number of subintervals must be even (len(x)-1 even).")
\end{minted}
The variable \verb|n| denotes the number of subintervals, computed as \(\text{len}(x)-1\).
The method requires an even number of subintervals, and the conditional statement enforces this by raising an exception when the requirement is violated.
\begin{minted}[breaklines]{python}
    h = (x[-1] - x[0]) / n
    luas = y[0] + y[-1]
\end{minted}
The expression \verb|h = (x[-1] - x[0]) / n| defines the uniform spacing between nodes.
The quantity \verb|luas| is initialized as the sum of the endpoint values \(y_{0} + y_{n}\).
\begin{minted}[breaklines]{python}
    for i in range(1, n):
        if i % 2 == 0:
            luas += 2 * y[i]
        else:
            luas += 4 * y[i]
\end{minted}
The subsequent loop iterates over the interior indices.
When the index \(i\) is even, the contribution \(2y_{i}\) is added, whereas for odd \(i\) the contribution \(4y_{i}\) is used.
\begin{minted}[breaklines]{python}
    return luas * h / 3
\end{minted}
The returned value \verb|luas * h / 3| constitutes the composite Simpson approximation to the definite integral of the function sampled at the nodes \(x_{i}\).

\subsection{Gaussian Quadrature}
For given points $x_i$, solve
\begin{equation*}
    \begin{bmatrix}
        P_0(x_0) & P_0(x_1) & \cdots & P_0(x_N) \\ P_i(x_0) & P_i(x_1) & \cdots & P_i(x_N) \\ \vdots & \vdots & \ddots & \vdots \\ P_N(x_0) & P_N(x_1) & \cdots & P_N(x_N)
    \end{bmatrix}
    \begin{bmatrix}
        w_0 \\ w_1 \\ \vdots \\ w_W
    \end{bmatrix}
    =
    \begin{bmatrix}
        2 \\ 0 \\ \vdots \\ 0
    \end{bmatrix}
\end{equation*}
With the solution $w_i$, then the integral can be approximated as
\begin{equation*}
    \int_{-1 }^{1 }f(x)\;dx \approx \sum_{i=0 }^{N }f(x_i )w_i
\end{equation*}
for arbitrary range
\begin{equation*}
    \int_{a}^{b }f(x)\;dx \approx \frac{b-a}{2}\sum_{i=0 }^{N }f \left[\frac{b-a}{2} x_i + \frac{a+b}{2}\right]
\end{equation*}

Gauss-Laguerre quadrature is defined as
\begin{equation*}
    \int_{0}^{\infty} e^{-x} f(x)\; dx \approx \sum_{i=1}^{n} w_i f(x_i)
\end{equation*}
For arbitrary function $g(x)$, write $f(x)=e^xg(x)$
\begin{equation*}
    \int_{0}^{\infty} g(x) \;dx \approx \sum_{i=1}^{n} w_{i} e^{x_{i}} g(x_{i})
\end{equation*}
The Gauss–Laguerre weights $w_i$ are determined uniquely by the roots of $L_n(x)$, and the explicit formula
\begin{equation*}
    w_{i} = \frac{x_{i}}{[(n+1)L_{n+1}(x_{i})]^{2}}
\end{equation*}
where $x_i$ is root and $L_n(x)$ is the degree-$n$ (physicists’) Laguerre polynomial
\begin{equation*}
    L_n(x)=\sum_{m=0}^{n}(-1)^m\binom{n}{m}\frac{x^m}{m!}
\end{equation*}
Evaluate the next order of Laguerre polynomial by the recurrence relation
\begin{equation*}
    L'_{n}(x_{i}) = -\frac{L_{n+1}(x_{i})}{x_{i}}
\end{equation*}

\subsubsection{Implementation.}
\begin{minted}[breaklines]{python}
def GaussLaguerre(n, g):
\end{minted}
The function \verb|GaussLaguerre| implements the Gauss–Laguerre quadrature for approximating integrals of the form $\int_{0}^{\infty} e^{-x} g(x)\, dx$ of order \verb|n|.
\begin{minted}[breaklines]{python}
    Ln = Laguerre.basis(n)
    Lnp1 = Laguerre.basis(n + 1)
    xi = Ln.roots()
\end{minted}
The expression \verb|Ln = Laguerre.basis(n)| constructs the Laguerre polynomial \(L_n(x)\), while \verb|Lnp1 = Laguerre.basis(n+1)| constructs the polynomial \(L_{n+1}(x)\).
The command \verb|xi = Ln.roots()| computes the quadrature nodes as the roots of \(L_n(x)\).
\begin{minted}[breaklines]{python}
    wi = xi / ((n + 1) * Lnp1(xi)) ** 2
\end{minted}
The quantity \verb|wi| represents the quadrature weights.
They follow from the analytic expression
\begin{equation*}
    w_i = \frac{x_i}{(n+1)^{2} [L_{n+1}(x_i)]^{2}}
\end{equation*}
which is a consequence of the orthogonality relations of Laguerre polynomials with respect to the weight function \(e^{-x}\).
\begin{minted}[breaklines]{python}
    return np.sum(wi * np.exp(xi) * g(xi))
\end{minted}
The returned value is the quadrature sum.
The final result thus approximates the desired integral with accuracy governed by the chosen order \(n\).

\end{document}